<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RAM Stress Tester</title>
    <!-- Favicon links -->
    <link rel="apple-touch-icon" sizes="180x180" href="../images/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../images/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../images/favicon/favicon-16x16.png">
    <link rel="icon" type="image/x-icon" href="../images/favicon/favicon.ico">
    <link rel="manifest" href="../images/favicon/site.webmanifest">
    <link rel="icon" type="image/png" sizes="192x192" href="../images/favicon/android-chrome-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="../images/favicon/android-chrome-512x512.png">
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body class="bg-gray-100 min-h-screen flex flex-col">
    <header class="bg-blue-500 shadow">
      <nav class="container mx-auto flex justify-center py-4">
        <a href="../index.html" class="mx-4 text-white hover:text-gray-200">My Other Sites</a>
      </nav>
    </header>
    <main class="container mx-auto px-4 mt-10 flex-grow">
      <div class="space-y-6">

        <!-- Last Run -->
        <article class="border p-6 rounded-lg bg-white shadow-lg">
          <h2 class="text-xl font-semibold mb-4">Last Run</h2>
          <div id="lastRunDisplay" class="text-gray-600">No previous runs found</div>
        </article>

        <!-- Automatic Stress Test -->
        <article class="border p-6 rounded-lg bg-white shadow-lg">
          <h2 class="text-xl font-semibold mb-4">Automatic RAM Stress Test</h2>
          <p class="text-gray-700 mb-4">This will gradually allocate memory until the browser crashes or reaches its limit.</p>
          <button id="startAutoTest" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded mr-4">Start Auto Test</button>
          <button id="stopAutoTest" class="bg-gray-400 text-gray-600 px-4 py-2 rounded" disabled>Stop Test</button>
          <div id="autoTestResults" class="mt-4"></div>
        </article>

        <!-- Manual RAM Test -->
        <article class="border p-6 rounded-lg bg-white shadow-lg">
          <h2 class="text-xl font-semibold mb-4">Manual RAM Test</h2>
          <p class="text-gray-700 mb-4">Test a specific amount of RAM allocation.</p>
          
          <div class="mb-4 flex items-end space-x-6">
            <div>
              <label class="block text-sm font-medium mb-2">Amount (MB):</label>
              <div class="flex items-center space-x-2">
                <input type="number" id="ramInput" min="8" max="131072" value="1024" class="border rounded px-3 py-2 w-32">
                <span class="text-sm text-gray-600">MB</span>
              </div>
            </div>
            <div>
              <label class="block text-sm font-medium mb-2">Hold Duration (seconds):</label>
              <input type="number" id="holdDuration" min="1" max="300" value="30" class="border rounded px-3 py-2 w-20">
            </div>
          </div>

          <button id="startManualTest" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded mr-4">Test Memory</button>
          <button id="stopManualTest" class="bg-gray-400 text-gray-600 px-4 py-2 rounded" disabled>Stop Test</button>
          <div id="manualTestResults" class="mt-4"></div>
        </article>

        <!-- Previous Runs -->
        <article class="border p-6 rounded-lg bg-white shadow-lg">
          <h2 class="text-xl font-semibold mb-4">Previous Runs</h2>
          <div id="previousRunsDisplay" class="text-gray-600">No previous runs found</div>
        </article>

      </div>
    </main>
    <footer class="py-4 mt-auto">
      <div class="text-center space-y-2">
        <p class="text-gray-600">&copy; <span id="currentYear"></span>. All rights reserved. </p>
        <p class="text-gray-600">Created by Alex with ❤️</p>
      </div>
    </footer>
    <script>
      document.getElementById('currentYear').textContent = new Date().getFullYear();

      class RAMTester {
        constructor() {
          this.allocatedMemory = [];
          this.isAutoTestRunning = false;
          this.isManualTestRunning = false;
          this.autoTestInterval = null;
          this.currentAllocatedMB = 0;
          this.maxReachedMB = 0;
          this.baseJsonData = null;
          this.currentRunId = null;
          this.saveInterval = null;
          
          this.initializeLocalStorage();
          this.generateBaseJsonData();
          this.initializeEventListeners();
          this.displaySystemInfo();
          this.updateRunDisplays();
        }

        initializeLocalStorage() {
          const existingRuns = localStorage.getItem('runs');
          if (!existingRuns) {
            localStorage.setItem('runs', JSON.stringify([]));
          } else {
            this.handleCrashedRuns();
          }
        }

        handleCrashedRuns() {
          try {
            const runs = JSON.parse(localStorage.getItem('runs') || '[]');
            let updated = false;
            
            runs.forEach(run => {
              if (run.status === 'running') {
                run.status = 'crashed';
                run.endTime = run.lastUpdate || run.startTime;
                updated = true;
              }
            });
            
            if (updated) {
              localStorage.setItem('runs', JSON.stringify(runs));
            }
          } catch (error) {
            console.warn('Failed to handle crashed runs:', error);
          }
        }

        generateRunId() {
          return Date.now() + '_' + Math.random().toString(36).substring(2, 9);
        }

        saveRunData(runData) {
          try {
            const runs = JSON.parse(localStorage.getItem('runs') || '[]');
            
            const existingRunIndex = runs.findIndex(run => run.id === runData.id);
            if (existingRunIndex >= 0) {
              runs[existingRunIndex] = runData;
            } else {
              runs.push(runData);
            }
            
            if (runs.length > 100) {
              runs.splice(0, runs.length - 100);
            }
            
            localStorage.setItem('runs', JSON.stringify(runs));
            this.updateRunDisplays();
          } catch (error) {
            console.warn('Failed to save run data:', error);
          }
        }

        startPeriodicSaving() {
          if (this.saveInterval) {
            clearInterval(this.saveInterval);
          }
          
          this.saveInterval = setInterval(() => {
            if (this.currentRunId && (this.isAutoTestRunning || this.isManualTestRunning)) {
              this.updateCurrentRun();
            }
          }, 1000);
        }

        stopPeriodicSaving() {
          if (this.saveInterval) {
            clearInterval(this.saveInterval);
            this.saveInterval = null;
          }
        }

        updateCurrentRun() {
          if (!this.currentRunId) return;
          
          const runs = JSON.parse(localStorage.getItem('runs') || '[]');
          const runIndex = runs.findIndex(run => run.id === this.currentRunId);
          
          if (runIndex >= 0) {
            runs[runIndex].currentMB = this.currentAllocatedMB;
            runs[runIndex].maxMB = this.maxReachedMB;
            runs[runIndex].lastUpdate = Date.now();
            
            if (!this.isAutoTestRunning && !this.isManualTestRunning) {
              runs[runIndex].endTime = Date.now();
              runs[runIndex].status = 'completed';
            }
            
            localStorage.setItem('runs', JSON.stringify(runs));
            this.updateRunDisplays();
          }
        }

        updateRunDisplays() {
          try {
            const runs = JSON.parse(localStorage.getItem('runs') || '[]');
            
            if (runs.length === 0) {
              document.getElementById('lastRunDisplay').innerHTML = '<div class="text-gray-600">No previous runs found</div>';
              document.getElementById('previousRunsDisplay').innerHTML = '<div class="text-gray-600">No previous runs found</div>';
              return;
            }
            
            // Sort by timestamp to get most recent first
            const sortedRuns = runs.sort((a, b) => (b.startTime || 0) - (a.startTime || 0));
            const lastRun = sortedRuns[0];
            const previousRuns = sortedRuns.slice(1);
            
            // Display last run
            const lastRunHtml = this.formatRunDisplay(lastRun, true);
            document.getElementById('lastRunDisplay').innerHTML = lastRunHtml;
            
            // Display previous runs
            if (previousRuns.length === 0) {
              document.getElementById('previousRunsDisplay').innerHTML = '<div class="text-gray-600">No previous runs found</div>';
            } else {
              const previousRunsHtml = previousRuns.map(run => this.formatRunDisplay(run, false)).join('');
              document.getElementById('previousRunsDisplay').innerHTML = previousRunsHtml;
            }
          } catch (error) {
            console.warn('Failed to update run displays:', error);
          }
        }

        formatRunDisplay(run, isLastRun) {
          const date = new Date(run.startTime).toLocaleDateString();
          const time = new Date(run.startTime).toLocaleTimeString();
          const duration = run.endTime ? 
            Math.round((run.endTime - run.startTime) / 1000) + 's' : 
            'Running...';
          
          const statusClass = run.status === 'completed' ? 'text-green-600' : 
                             run.status === 'running' ? 'text-blue-600' : 
                             run.status === 'crashed' ? 'text-red-600' : 'text-gray-600';
          
          const typeDisplay = run.type === 'automatic' ? 'Auto Test' : 
                             `Manual Test (${run.targetMB}MB for ${run.holdDuration}s)`;
          
          return `
            <div class="mb-4 p-4 border rounded ${isLastRun ? 'bg-blue-50' : 'bg-gray-50'}">
              <div class="flex justify-between items-start mb-2">
                <div class="font-medium">${typeDisplay}</div>
                <div class="text-sm text-gray-500">${date} ${time}</div>
              </div>
              <div class="text-sm space-y-1">
                <div>Max RAM: <span class="font-medium">${run.maxMB || 0}MB</span></div>
                <div>Duration: <span class="font-medium">${duration}</span></div>
                <div class="${statusClass}">Status: ${run.status || 'unknown'}</div>
              </div>
            </div>
          `;
        }


        initializeEventListeners() {
          // Auto test controls
          document.getElementById('startAutoTest').addEventListener('click', () => this.startAutoTest());
          document.getElementById('stopAutoTest').addEventListener('click', () => this.stopAutoTest());
          
          // Manual test
          document.getElementById('startManualTest').addEventListener('click', () => this.startManualTest());
          document.getElementById('stopManualTest').addEventListener('click', () => this.stopManualTest());
        }

        displaySystemInfo() {
          const info = document.getElementById('systemInfo');
          let memoryInfo = '';
          
          if (navigator.deviceMemory) {
            memoryInfo = `Device RAM: ~${navigator.deviceMemory}GB | `;
          }
          
          if (performance.memory) {
            const used = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
            const total = Math.round(performance.memory.totalJSHeapSize / 1024 / 1024);
            const limit = Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024);
            memoryInfo += `JS Heap: ${used}MB used / ${total}MB total / ${limit}MB limit`;
          }
          
          info.innerHTML = memoryInfo;
        }



        generateBaseJsonData() {
          // Generate approximately 1MB of JSON data
          const data = {
            metadata: {
              purpose: "RAM testing data",
              size_target: "1MB",
              generated_by: "RAM Tester",
              version: "1.0"
            },
            test_data: {
              arrays: [],
              objects: {},
              strings: [],
              numbers: []
            }
          };

          // Add arrays with various data types
          for (let i = 0; i < 50; i++) {
            const arr = [];
            for (let j = 0; j < 100; j++) {
              arr.push(Math.floor(Math.random() * 1000000));
            }
            data.test_data.arrays.push(arr);
          }

          // Add objects with nested structures
          for (let i = 0; i < 20; i++) {
            const objKey = `object_${i}`;
            data.test_data.objects[objKey] = {
              id: i,
              name: this.generateRandomString(50),
              description: this.generateRandomString(200),
              properties: {
                type: ["A", "B", "C", "D"][Math.floor(Math.random() * 4)],
                value: Math.random() * 1000,
                active: Math.random() > 0.5,
                tags: Array.from({length: 10}, () => this.generateRandomString(10))
              },
              nested_data: {
                level1: {
                  level2: {
                    level3: {
                      data: Array.from({length: 50}, () => Math.floor(Math.random() * 100))
                    }
                  }
                }
              }
            };
          }

          // Add large strings
          for (let i = 0; i < 10; i++) {
            data.test_data.strings.push(this.generateRandomString(5000));
          }

          // Add numbers array
          data.test_data.numbers = Array.from({length: 1000}, () => Math.random() * 2000 - 1000);

          // Add padding to reach approximately 1MB
          const jsonString = JSON.stringify(data);
          const currentSize = new Blob([jsonString]).size;
          const targetSize = 1048576; // 1MB
          
          if (currentSize < targetSize) {
            const paddingNeeded = targetSize - currentSize - 100;
            if (paddingNeeded > 0) {
              data.test_data.padding = this.generateRandomString(paddingNeeded);
            }
          }

          this.baseJsonData = data;
          console.log(`Generated base JSON data: ~${Math.round(new Blob([JSON.stringify(data)]).size / 1024)}KB`);
        }

        generateRandomString(length) {
          const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
          let result = '';
          for (let i = 0; i < length; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
          }
          return result;
        }

        allocateMemory(sizeMB) {
          try {
            if (!this.baseJsonData) {
              console.error('Base JSON data not ready');
              return false;
            }

            // Calculate how many copies we need (each copy is ~1MB)
            const copiesNeeded = Math.max(1, Math.round(sizeMB));
            const copies = [];
            
            for (let i = 0; i < copiesNeeded; i++) {
              // Create deep copy using JSON parse/stringify
              const copy = JSON.parse(JSON.stringify(this.baseJsonData));
              
              // Add some uniqueness to prevent optimization
              copy.copy_id = i;
              copy.timestamp = Date.now();
              copy.random_data = Math.random();
              
              copies.push(copy);
            }
            
            this.allocatedMemory.push(...copies);
            this.currentAllocatedMB += sizeMB;
            this.maxReachedMB = Math.max(this.maxReachedMB, this.currentAllocatedMB);
            
            console.log(`Allocated ${sizeMB}MB (${copiesNeeded} copies), total: ${this.currentAllocatedMB}MB`);
            return true;
          } catch (error) {
            console.error('Memory allocation failed:', error);
            return false;
          }
        }

        releaseMemory() {
          this.allocatedMemory = [];
          this.currentAllocatedMB = 0;
          // Force garbage collection if available
          if (window.gc) {
            window.gc();
          }
        }

        startAutoTest() {
          this.isAutoTestRunning = true;
          document.getElementById('startAutoTest').disabled = true;
          document.getElementById('stopAutoTest').disabled = false;
          document.getElementById('stopAutoTest').className = 'bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded';
          
          this.currentRunId = this.generateRunId();
          const runData = {
            id: this.currentRunId,
            type: 'automatic',
            startTime: Date.now(),
            endTime: null,
            maxMB: 0,
            currentMB: 0,
            status: 'running',
            lastUpdate: Date.now()
          };
          this.saveRunData(runData);
          this.startPeriodicSaving();
          
          const resultsDiv = document.getElementById('autoTestResults');
          resultsDiv.innerHTML = '<div class="text-blue-600">Starting automatic RAM stress test...</div>';
          
          let currentMB = 50;
          let consecutiveFailures = 0;
          
          this.autoTestInterval = setInterval(() => {
            if (!this.isAutoTestRunning) return;
            
            const success = this.allocateMemory(currentMB);
            
            if (success) {
              consecutiveFailures = 0;
              resultsDiv.innerHTML = `
                <div class="text-green-600">
                  <strong>Currently allocated: ${this.currentAllocatedMB}MB</strong><br>
                  <small>Last allocation: ${currentMB}MB - Success</small>
                </div>`;
              
              // Progress is now saved automatically every second
              
              // Increase allocation size gradually
              currentMB = Math.min(currentMB + 25, 500);
              this.displaySystemInfo();
            } else {
              consecutiveFailures++;
              
              if (consecutiveFailures >= 3) {
                this.stopAutoTest();
                
                resultsDiv.innerHTML = `
                  <div class="text-red-600">
                    <strong>Test completed!</strong><br>
                    Maximum RAM allocated: <strong>${this.maxReachedMB}MB</strong><br>
                    <small>Browser/system limit reached after ${consecutiveFailures} failed attempts</small>
                  </div>`;
                return;
              }
              
              resultsDiv.innerHTML = `
                <div class="text-orange-600">
                  <strong>Currently allocated: ${this.currentAllocatedMB}MB</strong><br>
                  <small>Last allocation: ${currentMB}MB - Failed (${consecutiveFailures}/3)</small>
                </div>`;
            }
          }, 500);
        }

        stopAutoTest() {
          this.isAutoTestRunning = false;
          if (this.autoTestInterval) {
            clearInterval(this.autoTestInterval);
          }
          
          this.updateCurrentRun();
          this.stopPeriodicSaving();
          
          document.getElementById('startAutoTest').disabled = false;
          document.getElementById('stopAutoTest').disabled = true;
          document.getElementById('stopAutoTest').className = 'bg-gray-400 text-gray-600 px-4 py-2 rounded';
          
          const resultsDiv = document.getElementById('autoTestResults');
          if (this.maxReachedMB > 0) {
            resultsDiv.innerHTML = `
              <div class="text-blue-600">
                <strong>Test stopped</strong><br>
                Maximum RAM reached: <strong>${this.maxReachedMB}MB</strong><br>
                Currently holding: ${this.currentAllocatedMB}MB
              </div>`;
          }
        }


        async startManualTest() {
          const amountMB = parseInt(document.getElementById('ramInput').value);
          const holdDuration = parseInt(document.getElementById('holdDuration').value);
          const resultsDiv = document.getElementById('manualTestResults');
          
          this.isManualTestRunning = true;
          document.getElementById('startManualTest').disabled = true;
          document.getElementById('stopManualTest').disabled = false;
          document.getElementById('stopManualTest').className = 'bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded';
          
          this.currentRunId = this.generateRunId();
          const runData = {
            id: this.currentRunId,
            type: 'manual',
            startTime: Date.now(),
            endTime: null,
            targetMB: amountMB,
            holdDuration: holdDuration,
            maxMB: 0,
            currentMB: 0,
            status: 'running',
            lastUpdate: Date.now()
          };
          this.saveRunData(runData);
          this.startPeriodicSaving();
          
          resultsDiv.innerHTML = '<div class="text-blue-600">Testing memory allocation...</div>';
          
          // Release previous allocations
          this.releaseMemory();
          
          const success = this.allocateMemory(amountMB);
          
          if (success && this.isManualTestRunning) {
            resultsDiv.innerHTML = `<div class="text-green-600"><strong>Success!</strong> Allocated ${amountMB}MB of RAM - holding for ${holdDuration} seconds...</div>`;
            
            // Wait for the specified duration with ability to stop
            for (let i = 0; i < holdDuration && this.isManualTestRunning; i++) {
              await new Promise(resolve => setTimeout(resolve, 1000));
              if (this.isManualTestRunning) {
                resultsDiv.innerHTML = `<div class="text-green-600"><strong>Holding...</strong> ${amountMB}MB allocated - ${holdDuration - i - 1} seconds remaining</div>`;
              }
            }
            
            if (this.isManualTestRunning) {
              resultsDiv.innerHTML = `<div class="text-green-600"><strong>Test completed!</strong> Successfully held ${amountMB}MB for ${holdDuration} seconds</div>`;
            }
          } else if (!success) {
            resultsDiv.innerHTML = `<div class="text-red-600"><strong>Failed</strong> to allocate ${amountMB}MB of RAM</div>`;
          }
          
          this.stopManualTest();
          this.displaySystemInfo();
        }

        stopManualTest() {
          this.isManualTestRunning = false;
          this.updateCurrentRun();
          this.stopPeriodicSaving();
          document.getElementById('startManualTest').disabled = false;
          document.getElementById('stopManualTest').disabled = true;
          document.getElementById('stopManualTest').className = 'bg-gray-400 text-gray-600 px-4 py-2 rounded';
        }

      }

      // Initialize the RAM tester when page loads
      window.addEventListener('load', () => {
        new RAMTester();
      });
    </script>
  </body>
</html>