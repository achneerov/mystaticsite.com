<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RAM Stress Tester</title>
    <!-- Favicon links -->
    <link rel="apple-touch-icon" sizes="180x180" href="../images/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../images/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../images/favicon/favicon-16x16.png">
    <link rel="icon" type="image/x-icon" href="../images/favicon/favicon.ico">
    <link rel="manifest" href="../images/favicon/site.webmanifest">
    <link rel="icon" type="image/png" sizes="192x192" href="../images/favicon/android-chrome-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="../images/favicon/android-chrome-512x512.png">
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body class="bg-gray-100 min-h-screen flex flex-col">
    <header class="bg-blue-500 shadow">
      <nav class="container mx-auto flex justify-center py-4">
        <a href="../index.html" class="mx-4 text-white hover:text-gray-200">My Other Sites</a>
      </nav>
    </header>
    <main class="container mx-auto px-4 mt-10 flex-grow">
      <div class="space-y-6">

        <!-- Current/Previous Run -->
        <article class="border p-6 rounded-lg bg-white shadow-lg">
          <h2 class="text-xl font-semibold mb-4">Current/Previous Run</h2>
          <div id="lastRunDisplay" class="text-gray-600">No previous runs found</div>
        </article>

        <!-- Automatic Stress Test -->
        <article class="border p-6 rounded-lg bg-white shadow-lg">
          <h2 class="text-xl font-semibold mb-4">Automatic RAM Stress Test</h2>
          <p class="text-gray-700 mb-4">This will gradually allocate memory until the browser crashes or reaches its limit.</p>
          <button id="startAutoTest" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded mr-4">Start Auto Test</button>
          <button id="stopAutoTest" class="bg-gray-400 text-gray-600 px-4 py-2 rounded" disabled>Stop Test</button>
        </article>

        <!-- Manual RAM Test -->
        <article class="border p-6 rounded-lg bg-white shadow-lg">
          <h2 class="text-xl font-semibold mb-4">Manual RAM Test</h2>
          <p class="text-gray-700 mb-4">Test a specific amount of RAM allocation.</p>
          
          <div class="mb-4 flex items-end space-x-6">
            <div>
              <label class="block text-sm font-medium mb-2">Amount (MB):</label>
              <div class="flex items-center space-x-2">
                <input type="number" id="ramInput" min="8" max="131072" value="1024" class="border rounded px-3 py-2 w-32">
                <span class="text-sm text-gray-600">MB</span>
              </div>
            </div>
            <div>
              <label class="block text-sm font-medium mb-2">Hold Duration (seconds):</label>
              <input type="number" id="holdDuration" min="1" max="300" value="30" class="border rounded px-3 py-2 w-20">
            </div>
          </div>

          <button id="startManualTest" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded mr-4">Test Memory</button>
          <button id="stopManualTest" class="bg-gray-400 text-gray-600 px-4 py-2 rounded" disabled>Stop Test</button>
        </article>

        <!-- All Runs -->
        <article class="border p-6 rounded-lg bg-white shadow-lg">
          <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-semibold">All Runs</h2>
            <button id="clearHistory" class="bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded text-sm">Clear History</button>
          </div>
          <div id="previousRunsDisplay" class="text-gray-600">No previous runs found</div>
        </article>

      </div>
    </main>
    <footer class="py-4 mt-auto">
      <div class="text-center space-y-2">
        <p class="text-gray-600">&copy; <span id="currentYear"></span>. All rights reserved. </p>
        <p class="text-gray-600">Created by Alex with ❤️</p>
      </div>
    </footer>
    <script>
      document.getElementById('currentYear').textContent = new Date().getFullYear();

      class RAMTester {
        constructor() {
          this.allocatedMemory = [];
          this.isAutoTestRunning = false;
          this.isManualTestRunning = false;
          this.autoTestInterval = null;
          this.currentAllocatedMB = 0;
          this.maxReachedMB = 0;
          this.baseJsonData = null;
          this.currentRunId = null;
          this.saveInterval = null;
          
          this.initializeLocalStorage();
          this.generateBaseJsonData();
          this.initializeEventListeners();
          this.updateRunDisplays();
        }

        initializeLocalStorage() {
          const existingData = localStorage.getItem('ramtester-data');
          if (!existingData) {
            const initialData = { runs: [] };
            localStorage.setItem('ramtester-data', JSON.stringify(initialData));
          } else {
            this.handleCrashedRuns();
          }
        }

        handleCrashedRuns() {
          try {
            const data = JSON.parse(localStorage.getItem('ramtester-data') || '{"runs":[]}');
            const runs = data.runs || [];
            let updated = false;
            
            runs.forEach(run => {
              if (run.status === 'running') {
                run.status = 'crashed';
                run.endTime = run.lastUpdate || run.startTime;
                updated = true;
              }
            });
            
            if (updated) {
              data.runs = runs;
              localStorage.setItem('ramtester-data', JSON.stringify(data));
            }
          } catch (error) {
            console.warn('Failed to handle crashed runs:', error);
          }
        }

        generateRunId() {
          return Date.now() + '_' + Math.random().toString(36).substring(2, 9);
        }

        saveRunData(runData) {
          try {
            const data = JSON.parse(localStorage.getItem('ramtester-data') || '{"runs":[]}');
            const runs = data.runs || [];
            
            const existingRunIndex = runs.findIndex(run => run.id === runData.id);
            if (existingRunIndex >= 0) {
              runs[existingRunIndex] = runData;
            } else {
              runs.push(runData);
            }
            
            if (runs.length > 100) {
              runs.splice(0, runs.length - 100);
            }
            
            data.runs = runs;
            localStorage.setItem('ramtester-data', JSON.stringify(data));
            this.updateRunDisplays();
          } catch (error) {
            console.warn('Failed to save run data:', error);
          }
        }

        startPeriodicSaving() {
          if (this.saveInterval) {
            clearInterval(this.saveInterval);
          }
          
          this.saveInterval = setInterval(() => {
            if (this.currentRunId && (this.isAutoTestRunning || this.isManualTestRunning)) {
              this.updateCurrentRun();
            }
          }, 1000);
        }

        stopPeriodicSaving() {
          if (this.saveInterval) {
            clearInterval(this.saveInterval);
            this.saveInterval = null;
          }
        }

        updateCurrentRun() {
          if (!this.currentRunId) return;
          
          const data = JSON.parse(localStorage.getItem('ramtester-data') || '{"runs":[]}');
          const runs = data.runs || [];
          const runIndex = runs.findIndex(run => run.id === this.currentRunId);
          
          if (runIndex >= 0) {
            runs[runIndex].currentMB = this.currentAllocatedMB;
            runs[runIndex].maxMB = this.maxReachedMB;
            runs[runIndex].lastUpdate = Date.now();
            
            if (!this.isAutoTestRunning && !this.isManualTestRunning) {
              runs[runIndex].endTime = Date.now();
              runs[runIndex].status = 'completed';
            }
            
            data.runs = runs;
            localStorage.setItem('ramtester-data', JSON.stringify(data));
            this.updateRunDisplays();
          }
        }

        updateRunDisplays() {
          try {
            const data = JSON.parse(localStorage.getItem('ramtester-data') || '{"runs":[]}');
            const runs = data.runs || [];
            
            if (runs.length === 0) {
              document.getElementById('lastRunDisplay').innerHTML = '<div class="text-gray-600">No previous runs found</div>';
              document.getElementById('previousRunsDisplay').innerHTML = '<div class="text-gray-600">No previous runs found</div>';
              return;
            }
            
            // Sort by timestamp to get most recent first
            const sortedRuns = runs.sort((a, b) => (b.startTime || 0) - (a.startTime || 0));
            const lastRun = sortedRuns[0];
            
            // Display last run
            const lastRunHtml = this.formatRunDisplay(lastRun, true);
            document.getElementById('lastRunDisplay').innerHTML = lastRunHtml;
            
            // Display all runs (including the most recent one)
            const allRunsHtml = sortedRuns.map(run => this.formatRunDisplay(run, false)).join('');
            document.getElementById('previousRunsDisplay').innerHTML = allRunsHtml;
          } catch (error) {
            console.warn('Failed to update run displays:', error);
          }
        }

        formatRunDisplay(run, isLastRun) {
          const date = new Date(run.startTime).toLocaleDateString();
          const time = new Date(run.startTime).toLocaleTimeString();
          const duration = run.endTime ? 
            Math.round((run.endTime - run.startTime) / 1000) + 's' : 
            'Running...';
          
          const statusClass = run.status === 'completed' ? 'text-green-600' : 
                             run.status === 'running' ? 'text-blue-600 font-bold' : 
                             run.status === 'crashed' ? 'text-green-600' : 'text-gray-600';
          
          const typeDisplay = run.type === 'automatic' ? 'Auto Test' : 
                             `Manual Test (${run.targetMB}MB for ${run.holdDuration}s)`;
          
          return `
            <div class="mb-4 p-4 border rounded ${isLastRun ? 'bg-blue-50' : 'bg-gray-50'}">
              <div class="flex justify-between items-start mb-2">
                <div class="${isLastRun ? 'font-bold text-lg' : 'font-medium'}">${typeDisplay}</div>
                <div class="${isLastRun ? 'text-base' : 'text-sm'} text-gray-500">${date} ${time}</div>
              </div>
              <div class="${isLastRun ? 'text-base' : 'text-sm'} space-y-1">
                <div>Max RAM: <span class="font-medium">${run.maxMB || 0}MB</span></div>
                <div>Duration: <span class="font-medium">${duration}</span></div>
                <div class="${statusClass}">${run.status === 'running' ? '🔄 Currently Running' : run.status === 'crashed' ? 'Status: crashed (Which means we hit the ram limit, which is good!)' : `Status: ${run.status || 'unknown'}`}</div>
              </div>
            </div>
          `;
        }


        initializeEventListeners() {
          // Auto test controls
          document.getElementById('startAutoTest').addEventListener('click', () => this.startAutoTest());
          document.getElementById('stopAutoTest').addEventListener('click', () => this.stopAutoTest());
          
          // Manual test
          document.getElementById('startManualTest').addEventListener('click', () => this.startManualTest());
          document.getElementById('stopManualTest').addEventListener('click', () => this.stopManualTest());
          
          // Clear history
          document.getElementById('clearHistory').addEventListener('click', () => this.clearHistory());
        }




        generateBaseJsonData() {
          // Create base ArrayBuffer of 1MB
          const bufferSize = 1024 * 1024; // 1MB
          this.baseJsonData = new ArrayBuffer(bufferSize);
          
          // Fill with random data to prevent optimization
          const view = new Uint8Array(this.baseJsonData);
          for (let i = 0; i < view.length; i++) {
            view[i] = Math.floor(Math.random() * 256);
          }
          
          console.log(`Generated base ArrayBuffer: ${Math.round(bufferSize / 1024)}KB`);
        }

        generateRandomString(length) {
          const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
          let result = '';
          for (let i = 0; i < length; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
          }
          return result;
        }

        allocateMemory(sizeMB) {
          try {
            if (!this.baseJsonData) {
              console.error('Base ArrayBuffer not ready');
              return false;
            }

            // Calculate how many copies we need (each copy is ~1MB)
            const copiesNeeded = Math.max(1, Math.round(sizeMB));
            const copies = [];
            
            for (let i = 0; i < copiesNeeded; i++) {
              // Create new ArrayBuffer and copy data
              const copy = new ArrayBuffer(this.baseJsonData.byteLength);
              const copyView = new Uint8Array(copy);
              const sourceView = new Uint8Array(this.baseJsonData);
              
              // Copy data and add uniqueness to prevent optimization
              copyView.set(sourceView);
              copyView[0] = i % 256; // Make each buffer unique
              copyView[copyView.length - 1] = (Date.now() % 256);
              
              copies.push(copy);
            }
            
            this.allocatedMemory.push(...copies);
            this.currentAllocatedMB += sizeMB;
            this.maxReachedMB = Math.max(this.maxReachedMB, this.currentAllocatedMB);
            
            console.log(`Allocated ${sizeMB}MB (${copiesNeeded} buffers), total: ${this.currentAllocatedMB}MB`);
            return true;
          } catch (error) {
            console.error('Memory allocation failed:', error);
            return false;
          }
        }

        releaseMemory() {
          this.allocatedMemory = [];
          this.currentAllocatedMB = 0;
          // Force garbage collection if available
          if (window.gc) {
            window.gc();
          }
        }

        startAutoTest() {
          this.isAutoTestRunning = true;
          
          // Reset memory state for new test
          this.releaseMemory();
          this.maxReachedMB = 0;
          
          document.getElementById('startAutoTest').disabled = true;
          document.getElementById('stopAutoTest').disabled = false;
          document.getElementById('stopAutoTest').className = 'bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded';
          
          this.currentRunId = this.generateRunId();
          const runData = {
            id: this.currentRunId,
            type: 'automatic',
            startTime: Date.now(),
            endTime: null,
            maxMB: 0,
            currentMB: 0,
            status: 'running',
            lastUpdate: Date.now()
          };
          this.saveRunData(runData);
          this.startPeriodicSaving();
          
          
          let currentMB = 50;
          let consecutiveFailures = 0;
          
          this.autoTestInterval = setInterval(() => {
            if (!this.isAutoTestRunning) return;
            
            const success = this.allocateMemory(currentMB);
            
            if (success) {
              consecutiveFailures = 0;
              
              // Progress is now saved automatically every second
              
              // Increase allocation size gradually
              currentMB = Math.min(currentMB + 25, 500);
                } else {
              consecutiveFailures++;
              
              if (consecutiveFailures >= 3) {
                this.stopAutoTest();
                return;
              }
              
            }
          }, 500);
        }

        stopAutoTest() {
          this.isAutoTestRunning = false;
          if (this.autoTestInterval) {
            clearInterval(this.autoTestInterval);
          }
          
          this.updateCurrentRun();
          this.stopPeriodicSaving();
          
          // Release memory after test completes
          this.releaseMemory();
          
          document.getElementById('startAutoTest').disabled = false;
          document.getElementById('stopAutoTest').disabled = true;
          document.getElementById('stopAutoTest').className = 'bg-gray-400 text-gray-600 px-4 py-2 rounded';
          
        }


        async startManualTest() {
          const amountMB = parseInt(document.getElementById('ramInput').value);
          const holdDuration = parseInt(document.getElementById('holdDuration').value);
          
          this.isManualTestRunning = true;
          document.getElementById('startManualTest').disabled = true;
          document.getElementById('stopManualTest').disabled = false;
          document.getElementById('stopManualTest').className = 'bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded';
          
          this.currentRunId = this.generateRunId();
          const runData = {
            id: this.currentRunId,
            type: 'manual',
            startTime: Date.now(),
            endTime: null,
            targetMB: amountMB,
            holdDuration: holdDuration,
            maxMB: 0,
            currentMB: 0,
            status: 'running',
            lastUpdate: Date.now()
          };
          this.saveRunData(runData);
          this.startPeriodicSaving();
          
          // Release previous allocations
          this.releaseMemory();
          
          const success = this.allocateMemory(amountMB);
          
          if (success && this.isManualTestRunning) {
            // Wait for the specified duration with ability to stop
            for (let i = 0; i < holdDuration && this.isManualTestRunning; i++) {
              await new Promise(resolve => setTimeout(resolve, 1000));
            }
          }
          
          this.stopManualTest();
        }

        stopManualTest() {
          this.isManualTestRunning = false;
          this.updateCurrentRun();
          this.stopPeriodicSaving();
          document.getElementById('startManualTest').disabled = false;
          document.getElementById('stopManualTest').disabled = true;
          document.getElementById('stopManualTest').className = 'bg-gray-400 text-gray-600 px-4 py-2 rounded';
        }

        clearHistory() {
          if (confirm('Are you sure you want to clear all run history? This cannot be undone.')) {
            const data = { runs: [] };
            localStorage.setItem('ramtester-data', JSON.stringify(data));
            this.updateRunDisplays();
          }
        }

      }

      // Initialize the RAM tester when page loads
      window.addEventListener('load', () => {
        new RAMTester();
      });
    </script>
  </body>
</html>