<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebAI ‚Äî Local AI Chat in Your Browser</title>
    <meta name="description"
        content="Run an LLM entirely in your browser using WebGPU. Private, unmonitored, no server needed." />
    <link rel="apple-touch-icon" sizes="180x180" href="../images/favicon/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="../images/favicon/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="../images/favicon/favicon-16x16.png" />
    <link rel="icon" type="image/x-icon" href="../images/favicon/favicon.ico" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
        rel="stylesheet" />
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        *,
        *::before,
        *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: #171717;
            color: #e5e5e5;
            height: 100vh;
            overflow: hidden;
        }

        /* ‚îÄ‚îÄ Layout ‚îÄ‚îÄ */
        .app {
            display: flex;
            height: 100vh;
        }

        /* ‚îÄ‚îÄ Sidebar ‚îÄ‚îÄ */
        .sidebar {
            width: 260px;
            background: #0f0f0f;
            border-right: 1px solid #2a2a2a;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            transition: transform 0.25s ease;
        }

        .sidebar-header {
            padding: 14px 16px;
            border-bottom: 1px solid #2a2a2a;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .sidebar-brand {
            font-size: 1.05rem;
            font-weight: 700;
            color: #10b981;
            letter-spacing: -0.02em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sidebar-brand svg {
            width: 22px;
            height: 22px;
        }

        .btn-new-chat {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            background: #1f1f1f;
            border: 1px solid #333;
            border-radius: 8px;
            color: #d4d4d4;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.15s, border-color 0.15s;
        }

        .btn-new-chat:hover {
            background: #292929;
            border-color: #444;
        }

        .btn-new-chat svg {
            width: 16px;
            height: 16px;
        }

        .chat-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.08) transparent;
        }

        .chat-list::-webkit-scrollbar {
            width: 4px;
        }

        .chat-list::-webkit-scrollbar-track {
            background: transparent;
        }

        .chat-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 2px;
        }

        .chat-list-item {
            padding: 10px 12px;
            border-radius: 8px;
            font-size: 0.82rem;
            color: #a3a3a3;
            cursor: pointer;
            transition: background 0.12s, color 0.12s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            position: relative;
        }

        .chat-list-item:hover {
            background: #1f1f1f;
            color: #e5e5e5;
        }

        .chat-list-item.active {
            background: #262626;
            color: #fff;
        }

        .chat-list-item-title {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chat-delete {
            opacity: 0;
            background: none;
            border: none;
            color: #737373;
            cursor: pointer;
            padding: 2px;
            border-radius: 4px;
            transition: opacity 0.12s, color 0.12s;
            flex-shrink: 0;
        }

        .chat-list-item:hover .chat-delete {
            opacity: 1;
        }

        .chat-delete:hover {
            color: #ef4444;
        }

        .chat-delete svg {
            width: 14px;
            height: 14px;
        }

        .chat-list-empty {
            text-align: center;
            color: #525252;
            font-size: 0.78rem;
            padding: 24px 16px;
        }

        .sidebar-footer {
            padding: 12px 16px;
            border-top: 1px solid #2a2a2a;
            font-size: 0.7rem;
            color: #525252;
            text-align: center;
        }

        /* ‚îÄ‚îÄ Main ‚îÄ‚îÄ */
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        /* ‚îÄ‚îÄ Hamburger (mobile only) ‚îÄ‚îÄ */
        .hamburger-bar {
            display: none;
            padding: 8px 16px;
            border-bottom: 1px solid #2a2a2a;
            background: #171717;
        }

        .hamburger {
            background: none;
            border: none;
            color: #a3a3a3;
            cursor: pointer;
            padding: 4px;
        }

        .hamburger svg {
            width: 22px;
            height: 22px;
        }

        /* ‚îÄ‚îÄ Progress (always at top of main) ‚îÄ‚îÄ */
        .progress-strip {
            padding: 8px 20px;
            border-bottom: 1px solid #2a2a2a;
            display: none;
        }

        .progress-strip.show {
            display: block;
        }

        .progress-meta {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }

        .progress-meta span {
            font-size: 0.72rem;
            color: #737373;
        }

        .progress-meta .pct {
            color: #10b981;
            font-family: 'Inter', monospace;
        }

        .progress-track {
            height: 4px;
            border-radius: 2px;
            background: #262626;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            border-radius: 2px;
            background: #10b981;
            transition: width 0.3s ease;
        }

        /* ‚îÄ‚îÄ Chat area ‚îÄ‚îÄ */
        .chat-area {
            flex: 1;
            overflow-y: auto;
            padding: 24px 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            scroll-behavior: smooth;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.06) transparent;
        }

        .chat-area::-webkit-scrollbar {
            width: 5px;
        }

        .chat-area::-webkit-scrollbar-track {
            background: transparent;
        }

        .chat-area::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.06);
            border-radius: 3px;
        }

        /* Messages */
        .msg-row {
            display: flex;
            gap: 12px;
            max-width: 720px;
            width: 100%;
            margin: 0 auto;
            animation: fadeIn 0.2s ease;
        }

        .msg-row.user {
            justify-content: flex-end;
        }

        .msg-row.ai {
            justify-content: flex-start;
        }

        .msg-avatar {
            width: 30px;
            height: 30px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            font-size: 0.7rem;
            font-weight: 700;
        }

        .msg-avatar.ai-av {
            background: #10b981;
            color: #fff;
        }

        .msg-avatar.user-av {
            background: #3b82f6;
            color: #fff;
        }

        .msg-bubble {
            padding: 10px 16px;
            border-radius: 14px;
            line-height: 1.6;
            font-size: 0.9rem;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-width: 85%;
        }

        .msg-bubble.user-b {
            background: #262626;
            color: #e5e5e5;
            border-bottom-right-radius: 4px;
        }

        .msg-bubble.ai-b {
            background: #1f1f1f;
            color: #d4d4d4;
            border-bottom-left-radius: 4px;
            white-space: normal;
        }

        /* ‚îÄ‚îÄ Markdown inside AI bubbles ‚îÄ‚îÄ */
        .msg-bubble.ai-b p {
            margin: 0 0 8px 0;
        }

        .msg-bubble.ai-b p:last-child {
            margin-bottom: 0;
        }

        .msg-bubble.ai-b h1,
        .msg-bubble.ai-b h2,
        .msg-bubble.ai-b h3,
        .msg-bubble.ai-b h4,
        .msg-bubble.ai-b h5,
        .msg-bubble.ai-b h6 {
            color: #e5e5e5;
            margin: 12px 0 6px 0;
            line-height: 1.3;
        }

        .msg-bubble.ai-b h1 {
            font-size: 1.15rem;
        }

        .msg-bubble.ai-b h2 {
            font-size: 1.05rem;
        }

        .msg-bubble.ai-b h3 {
            font-size: 0.95rem;
        }

        .msg-bubble.ai-b ul,
        .msg-bubble.ai-b ol {
            margin: 6px 0;
            padding-left: 20px;
        }

        .msg-bubble.ai-b li {
            margin: 3px 0;
        }

        .msg-bubble.ai-b code {
            background: #2a2a2a;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 0.82rem;
            color: #10b981;
        }

        .msg-bubble.ai-b pre {
            background: #0d0d0d;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
            overflow-x: auto;
            position: relative;
        }

        .copy-btn {
            position: absolute;
            top: 6px;
            right: 6px;
            background: #262626;
            border: 1px solid #333;
            color: #a3a3a3;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 0.68rem;
            font-family: 'Inter', sans-serif;
            cursor: pointer;
            transition: background 0.15s, color 0.15s;
            z-index: 1;
        }

        .copy-btn:hover {
            background: #333;
            color: #e5e5e5;
        }

        .copy-btn.copied {
            background: #10b981;
            color: #fff;
            border-color: #10b981;
        }

        .msg-bubble.ai-b pre code {
            background: none;
            padding: 0;
            color: #d4d4d4;
            font-size: 0.8rem;
        }

        .msg-bubble.ai-b blockquote {
            border-left: 3px solid #10b981;
            padding-left: 12px;
            margin: 8px 0;
            color: #a3a3a3;
        }

        .msg-bubble.ai-b table {
            border-collapse: collapse;
            margin: 8px 0;
            width: 100%;
            font-size: 0.82rem;
        }

        .msg-bubble.ai-b th,
        .msg-bubble.ai-b td {
            border: 1px solid #333;
            padding: 6px 10px;
            text-align: left;
        }

        .msg-bubble.ai-b th {
            background: #262626;
            color: #e5e5e5;
        }

        .msg-bubble.ai-b hr {
            border: none;
            border-top: 1px solid #333;
            margin: 12px 0;
        }

        .msg-bubble.ai-b a {
            color: #10b981;
            text-decoration: underline;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(6px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Typing dots */
        .typing span {
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #10b981;
            margin: 0 2px;
            animation: dotBounce 1.4s infinite both;
        }

        .typing span:nth-child(2) {
            animation-delay: 0.15s;
        }

        .typing span:nth-child(3) {
            animation-delay: 0.3s;
        }

        @keyframes dotBounce {

            0%,
            80%,
            100% {
                transform: scale(0);
            }

            40% {
                transform: scale(1);
            }
        }

        /* Welcome */
        .welcome {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 32px 16px;
        }

        .welcome-icon {
            width: 56px;
            height: 56px;
            border-radius: 16px;
            background: linear-gradient(135deg, #10b981, #059669);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
            box-shadow: 0 8px 24px rgba(16, 185, 129, 0.15);
        }

        .welcome-icon svg {
            width: 28px;
            height: 28px;
            color: #fff;
        }

        .welcome h2 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #e5e5e5;
            margin-bottom: 8px;
        }

        .welcome p {
            font-size: 0.85rem;
            color: #737373;
            max-width: 380px;
            line-height: 1.6;
        }

        .welcome-tags {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            margin-top: 16px;
        }

        .welcome-tags span {
            font-size: 0.72rem;
            padding: 5px 12px;
            border-radius: 999px;
            background: #1f1f1f;
            border: 1px solid #2a2a2a;
            color: #737373;
        }

        /* ‚îÄ‚îÄ Input bar ‚îÄ‚îÄ */
        .input-bar {
            padding: 12px 20px 16px;
            border-top: 1px solid #2a2a2a;
            background: #171717;
        }

        .input-cell {
            display: flex;
            align-items: center;
            max-width: 720px;
            margin: 0 auto;
            background: #1f1f1f;
            border: 1px solid #333;
            border-radius: 12px;
            overflow: hidden;
            transition: border-color 0.15s;
        }


        /* Text input ‚Äî takes all remaining space */
        .input-cell input {
            flex: 1;
            min-width: 0;
            background: transparent;
            border: none;
            color: #e5e5e5;
            padding: 12px 16px;
            font-size: 0.9rem;
            font-family: 'Inter', sans-serif;
            outline: none;
        }

        .input-cell input::placeholder {
            color: #525252;
        }

        .input-cell input:disabled {
            opacity: 0.4;
        }

        /* Divider between input and model select */
        .input-divider {
            width: 1px;
            height: 22px;
            background: #333;
            flex-shrink: 0;
        }

        /* Model dropdown ‚Äî blends into the cell */
        .select-model {
            background: transparent;
            border: none;
            color: #a3a3a3;
            padding: 10px 28px 10px 12px;
            font-size: 0.76rem;
            font-family: 'Inter', sans-serif;
            outline: none;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' fill='%2310b981' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            flex-shrink: 0;
            max-width: 190px;
            transition: color 0.15s;
        }

        .select-model:hover {
            color: #d4d4d4;
        }

        .select-model option {
            background: #1f1f1f;
            color: #d4d4d4;
        }

        .select-model:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Send button ‚Äî sits flush on the right */
        .btn-send {
            width: 44px;
            height: 44px;
            background: #10b981;
            border: none;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: background 0.15s;
            border-radius: 0 11px 11px 0;
        }

        .btn-send:hover:not(:disabled) {
            background: #059669;
        }

        .btn-send:disabled {
            opacity: 0.35;
            cursor: not-allowed;
        }

        .btn-send svg {
            width: 18px;
            height: 18px;
        }

        .input-hint {
            text-align: center;
            font-size: 0.65rem;
            color: #404040;
            margin-top: 6px;
        }

        /* ‚îÄ‚îÄ Mobile sidebar overlay ‚îÄ‚îÄ */
        .sidebar-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 90;
        }

        .sidebar-overlay.show {
            display: block;
        }

        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                left: 0;
                top: 0;
                bottom: 0;
                z-index: 100;
                transform: translateX(-100%);
            }

            .sidebar.open {
                transform: translateX(0);
            }

            .hamburger-bar {
                display: flex;
            }

            .select-model {
                max-width: 120px;
                font-size: 0.7rem;
                padding-right: 24px;
            }
        }

        /* ‚îÄ‚îÄ Image features ‚îÄ‚îÄ */
        .btn-attach,
        .btn-generate {
            width: 40px;
            height: 44px;
            background: transparent;
            border: none;
            color: #737373;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: color 0.15s, background 0.15s;
        }

        .btn-attach:hover,
        .btn-generate:hover {
            color: #e5e5e5;
            background: rgba(255, 255, 255, 0.05);
        }

        .btn-attach svg,
        .btn-generate svg {
            width: 18px;
            height: 18px;
        }

        .btn-generate {
            color: #a78bfa;
        }

        .btn-generate:hover {
            color: #c4b5fd;
        }

        .image-preview-strip {
            display: flex;
            gap: 8px;
            padding: 8px 0 4px;
            max-width: 720px;
            margin: 0 auto;
            overflow-x: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.08) transparent;
        }

        .image-preview-strip:empty {
            display: none;
            padding: 0;
        }

        .preview-thumb {
            position: relative;
            width: 64px;
            height: 64px;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #333;
            flex-shrink: 0;
        }

        .preview-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .preview-thumb .remove-img {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 18px;
            height: 18px;
            background: rgba(0, 0, 0, 0.7);
            border: none;
            border-radius: 50%;
            color: #fff;
            font-size: 11px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            transition: background 0.15s;
        }

        .preview-thumb .remove-img:hover {
            background: #ef4444;
        }

        .image-in-bubble {
            max-width: 280px;
            border-radius: 10px;
            margin: 6px 0;
            cursor: pointer;
            transition: opacity 0.15s;
            display: block;
        }

        .image-in-bubble:hover {
            opacity: 0.85;
        }

        .generated-image-wrap {
            position: relative;
            display: inline-block;
            margin: 6px 0;
        }

        .generated-image-wrap img {
            max-width: 320px;
            border-radius: 10px;
            display: block;
        }

        .generated-image-wrap .dl-btn {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.7);
            border: none;
            color: #fff;
            padding: 5px 10px;
            border-radius: 6px;
            font-size: 0.7rem;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .generated-image-wrap:hover .dl-btn {
            opacity: 1;
        }

        .sd-progress {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            font-size: 0.82rem;
            color: #a78bfa;
        }

        .sd-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #a78bfa;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .lightbox {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
            cursor: zoom-out;
        }

        .lightbox.show {
            display: flex;
        }

        .lightbox img {
            max-width: 90vw;
            max-height: 90vh;
            border-radius: 8px;
        }
    </style>
</head>

<body>
    <div class="app">

        <!-- ‚ïê‚ïê Sidebar ‚ïê‚ïê -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-brand">
                    <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round"
                            d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09z" />
                    </svg>
                    WebAI
                </div>
                <button class="btn-new-chat" onclick="newChat()" title="New chat">
                    <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
                    </svg>
                    New
                </button>
            </div>
            <div class="chat-list" id="chatList">
                <div class="chat-list-empty" id="chatListEmpty">No conversations yet</div>
            </div>
            <div class="sidebar-footer">Runs 100% in your browser</div>
        </aside>

        <div class="sidebar-overlay" id="sidebarOverlay" onclick="closeSidebar()"></div>

        <!-- ‚ïê‚ïê Main area ‚ïê‚ïê -->
        <div class="main">

            <!-- Hamburger (mobile only) -->
            <div class="hamburger-bar">
                <button class="hamburger" onclick="toggleSidebar()" title="Menu">
                    <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round"
                            d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" />
                    </svg>
                </button>
            </div>

            <!-- Progress bar (at very top of main content) -->
            <div id="progressArea" class="progress-strip">
                <div class="progress-meta">
                    <span id="progressLabel">Loading‚Ä¶</span>
                    <span id="progressPct" class="pct">0%</span>
                </div>
                <div class="progress-track">
                    <div id="progressBar" class="progress-fill" style="width:0%"></div>
                </div>
            </div>

            <!-- Chat -->
            <div id="chatArea" class="chat-area">
                <div class="welcome" id="welcomeScreen">
                    <div class="welcome-icon">
                        <svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09zM18.259 8.715L18 9.75l-.259-1.035a3.375 3.375 0 00-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 002.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 002.455 2.456L21.75 6l-1.036.259a3.375 3.375 0 00-2.455 2.456z" />
                        </svg>
                    </div>
                    <h2>Welcome to WebAI</h2>
                    <p>Pick a model from the dropdown below and start chatting. Everything runs locally on your device ‚Äî
                        nothing leaves your browser.</p>
                    <div class="welcome-tags">
                        <span>üîí Fully Private</span>
                        <span>‚ö° WebGPU Accelerated</span>
                        <span>üåê No Server</span>
                        <span>üíæ Chats Saved Locally</span>
                    </div>
                </div>
            </div>

            <!-- Input bar with model selector -->
            <div class="input-bar">
                <div class="image-preview-strip" id="imagePreviewStrip"></div>
                <form class="input-cell" onsubmit="sendMessage(event)">
                    <input type="file" id="fileInput" accept="image/*" multiple hidden />
                    <button type="button" class="btn-attach" onclick="document.getElementById('fileInput').click()"
                        title="Attach image">
                        <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                d="M18.375 12.739l-7.693 7.693a4.5 4.5 0 01-6.364-6.364l10.94-10.94A3 3 0 1119.5 7.372L8.552 18.32m.009-.01l-.01.01m5.699-9.941l-7.81 7.81a1.5 1.5 0 002.112 2.13" />
                        </svg>
                    </button>
                    <input id="userInput" type="text" placeholder="Message WebAI‚Ä¶" autocomplete="off" disabled />
                    <button type="button" id="generateBtn" class="btn-generate" onclick="triggerGenerate()"
                        title="Generate image (üé®)">
                        <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                d="M9.53 16.122a3 3 0 00-5.78 1.128 2.25 2.25 0 01-2.4 2.245 4.5 4.5 0 008.4-2.245c0-.399-.078-.78-.22-1.128zm0 0a15.998 15.998 0 003.388-1.62m-5.043-.025a15.994 15.994 0 011.622-3.395m3.42 3.42a15.995 15.995 0 004.764-4.648l3.876-5.814a1.151 1.151 0 00-1.597-1.597L14.146 6.32a15.996 15.996 0 00-4.649 4.763m3.42 3.42a6.776 6.776 0 00-3.42-3.42" />
                        </svg>
                    </button>
                    <div class="input-divider"></div>
                    <select id="modelSelect" class="select-model">
                        <option value="SmolLM2-360M-Instruct-q4f16_1-MLC">SmolLM2 360M (~200 MB)</option>
                        <option value="SmolLM2-1.7B-Instruct-q4f16_1-MLC" selected>SmolLM2 1.7B (~1 GB)</option>
                        <option value="Qwen2.5-1.5B-Instruct-q4f16_1-MLC">Qwen 2.5 1.5B (~1 GB)</option>
                        <option value="Llama-3.2-1B-Instruct-q4f16_1-MLC">Llama 3.2 1B (~0.7 GB)</option>
                        <option value="Llama-3.2-3B-Instruct-q4f16_1-MLC">Llama 3.2 3B (~1.8 GB)</option>
                        <option value="Phi-3.5-mini-instruct-q4f16_1-MLC">Phi 3.5 Mini (~2.3 GB)</option>
                        <option value="gemma-2-2b-it-q4f16_1-MLC">Gemma 2 2B (~1.4 GB)</option>
                        <option value="Qwen2.5-3B-Instruct-q4f16_1-MLC">Qwen 2.5 3B (~1.9 GB)</option>
                        <option value="Mistral-7B-Instruct-v0.3-q4f16_1-MLC">Mistral 7B (~4 GB)</option>
                        <option value="Qwen2.5-7B-Instruct-q4f16_1-MLC">Qwen 2.5 7B (~4.5 GB)</option>
                        <option value="Llama-3.1-8B-Instruct-q4f16_1-MLC">Llama 3.1 8B (~5 GB)</option>
                        <option value="Qwen3-8B-q4f16_1-MLC">Qwen3 8B (~5.7 GB)</option>
                        <option value="gemma-2-9b-it-q4f16_1-MLC">Gemma 2 9B (~6.4 GB)</option>
                        <option value="Phi-3.5-vision-instruct-q4f16_1-MLC">üëÅÔ∏è Phi-3.5 Vision (~2.6 GB)</option>
                    </select>
                    <div class="input-divider"></div>
                    <button type="submit" id="sendBtn" class="btn-send" disabled title="Send">
                        <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                d="M6 12L3.269 3.126A59.768 59.768 0 0121.485 12 59.77 59.77 0 013.27 20.876L5.999 12zm0 0h7.5" />
                        </svg>
                    </button>
                </form>
                <div class="input-hint">WebAI runs entirely in your browser. Your conversations are never sent anywhere.
                </div>
            </div>
        </div>
    </div>

    <!-- Lightbox -->
    <div class="lightbox" id="lightbox" onclick="closeLightbox()"><img id="lightboxImg" src="" alt="Preview" /></div>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê WebGPU Limits Patch ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <!-- Older @mlc-ai/web-runtime doesn't request maxComputeInvocationsPerWorkgroup -->
    <!-- This patch ensures the limit is always included when requestDevice() is called -->
    <script>
        if (typeof navigator !== 'undefined' && navigator.gpu && GPUAdapter && GPUAdapter.prototype.requestDevice) {
            const _origRequestDevice = GPUAdapter.prototype.requestDevice;
            GPUAdapter.prototype.requestDevice = async function (descriptor) {
                descriptor = descriptor || {};
                descriptor.requiredLimits = descriptor.requiredLimits || {};
                const limits = descriptor.requiredLimits;
                // Inject higher compute limits if not already specified
                const computeKeys = [
                    'maxComputeInvocationsPerWorkgroup',
                    'maxComputeWorkgroupSizeX',
                    'maxComputeWorkgroupSizeY',
                    'maxComputeWorkgroupSizeZ',
                ];
                for (const key of computeKeys) {
                    if (limits[key] === undefined && this.limits[key] !== undefined) {
                        limits[key] = this.limits[key];
                    }
                }
                console.log('[WebGPU Patch] requestDevice with limits:', JSON.stringify(limits));
                return _origRequestDevice.call(this, descriptor);
            };
            console.log('[WebGPU Patch] GPUAdapter.requestDevice patched for compute limits');
        }
    </script>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê WebLLM + App Logic ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <script type="module">
        import * as webllm from "https://esm.run/@mlc-ai/web-llm";

        /* ‚ïê‚ïê State ‚ïê‚ïê */
        let engine = null;
        let isGenerating = false;
        let currentModelId = null;
        let isLoading = false;

        const STORAGE_KEY = "webai_chats";
        let chats = loadChats();
        let activeChatId = null;

        /* ‚îÄ‚îÄ Image state ‚îÄ‚îÄ */
        let pendingImages = []; // Array of dataURL strings
        const VISION_MODEL = "Phi-3.5-vision-instruct-q4f16_1-MLC";

        function isVisionModel(id) {
            return id === VISION_MODEL;
        }

        /* ‚îÄ‚îÄ DOM ‚îÄ‚îÄ */
        const chatArea = document.getElementById("chatArea");
        const welcomeScreen = document.getElementById("welcomeScreen");
        const userInput = document.getElementById("userInput");
        const sendBtn = document.getElementById("sendBtn");
        const modelSelect = document.getElementById("modelSelect");
        const progressArea = document.getElementById("progressArea");
        const progressLabel = document.getElementById("progressLabel");
        const progressPct = document.getElementById("progressPct");
        const progressBar = document.getElementById("progressBar");
        const chatListEl = document.getElementById("chatList");
        const sidebar = document.getElementById("sidebar");
        const sidebarOverlay = document.getElementById("sidebarOverlay");
        const fileInput = document.getElementById("fileInput");
        const previewStrip = document.getElementById("imagePreviewStrip");
        const lightbox = document.getElementById("lightbox");
        const lightboxImg = document.getElementById("lightboxImg");

        /* ‚îÄ‚îÄ Expose to inline handlers ‚îÄ‚îÄ */
        window.sendMessage = sendMessage;
        window.newChat = newChat;
        window.switchChat = switchChat;
        window.deleteChat = deleteChat;
        window.toggleSidebar = toggleSidebar;
        window.closeSidebar = closeSidebar;
        window.triggerGenerate = triggerGenerate;
        window.openLightbox = openLightbox;
        window.closeLightbox = closeLightbox;
        window.removePreviewImage = removePreviewImage;
        window.downloadGeneratedImage = downloadGeneratedImage;

        /* ‚ïê‚ïê Image upload handling ‚ïê‚ïê */
        function handleImageFiles(files) {
            files.forEach(f => {
                if (!f.type.startsWith("image/")) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    resizeImage(ev.target.result, 512).then(dataUrl => {
                        pendingImages.push(dataUrl);
                        renderPreviewStrip();
                        // Auto-suggest vision model if current is text-only
                        if (!isVisionModel(modelSelect.value) && pendingImages.length === 1) {
                            if (confirm("Image attached! Switch to the Phi-3.5 Vision model for image understanding?")) {
                                modelSelect.value = VISION_MODEL;
                                loadModel(VISION_MODEL);
                            }
                        }
                    });
                };
                reader.readAsDataURL(f);
            });
        }

        fileInput.addEventListener("change", (e) => {
            handleImageFiles(Array.from(e.target.files));
            fileInput.value = ""; // reset so same file can be re-selected
        });

        // Drag-and-drop image support
        chatArea.addEventListener("dragover", (e) => {
            e.preventDefault();
            chatArea.style.outline = "2px dashed #a78bfa";
        });
        chatArea.addEventListener("dragleave", () => {
            chatArea.style.outline = "";
        });
        chatArea.addEventListener("drop", (e) => {
            e.preventDefault();
            chatArea.style.outline = "";
            handleImageFiles(Array.from(e.dataTransfer.files));
        });

        function resizeImage(dataUrl, maxDim) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    let w = img.width, h = img.height;
                    if (w > maxDim || h > maxDim) {
                        if (w > h) { h = Math.round(h * maxDim / w); w = maxDim; }
                        else { w = Math.round(w * maxDim / h); h = maxDim; }
                    }
                    const canvas = document.createElement("canvas");
                    canvas.width = w; canvas.height = h;
                    const ctx = canvas.getContext("2d");
                    ctx.drawImage(img, 0, 0, w, h);
                    resolve(canvas.toDataURL("image/jpeg", 0.8));
                };
                img.src = dataUrl;
            });
        }

        function renderPreviewStrip() {
            previewStrip.innerHTML = pendingImages.map((src, i) =>
                `<div class="preview-thumb">
                    <img src="${src}" alt="Preview ${i + 1}" />
                    <button class="remove-img" onclick="removePreviewImage(${i})" title="Remove">&times;</button>
                </div>`
            ).join("");
        }

        function removePreviewImage(index) {
            pendingImages.splice(index, 1);
            renderPreviewStrip();
        }

        /* ‚ïê‚ïê Lightbox ‚ïê‚ïê */
        function openLightbox(src) {
            lightboxImg.src = src;
            lightbox.classList.add("show");
        }
        function closeLightbox() {
            lightbox.classList.remove("show");
            lightboxImg.src = "";
        }

        /* ‚ïê‚ïê Download helper ‚ïê‚ïê */
        function downloadGeneratedImage(src) {
            // Convert data URL to blob so the browser respects the filename extension
            fetch(src).then(r => r.blob()).then(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "webai_generated_" + Date.now() + ".png";
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
        }

        /* ‚ïê‚ïê Auto-load model on dropdown change ‚ïê‚ïê */
        modelSelect.addEventListener("change", () => {
            loadModel(modelSelect.value);
        });

        /* ‚ïê‚ïê LocalStorage ‚ïê‚ïê */
        function loadChats() {
            try { return JSON.parse(localStorage.getItem(STORAGE_KEY)) || []; }
            catch { return []; }
        }
        function saveChats() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(chats));
            } catch (e) {
                console.warn("localStorage save failed (possibly over quota):", e);
            }
        }
        function getActiveChat() {
            return chats.find(c => c.id === activeChatId) || null;
        }

        /* ‚ïê‚ïê Sidebar rendering ‚ïê‚ïê */
        function renderChatList() {
            if (chats.length === 0) {
                chatListEl.innerHTML = '<div class="chat-list-empty">No conversations yet</div>';
                return;
            }
            chatListEl.innerHTML = chats.map(c => {
                const isActive = c.id === activeChatId;
                return `<div class="chat-list-item ${isActive ? 'active' : ''}" onclick="switchChat('${c.id}')">
                <span class="chat-list-item-title">${escapeHTML(c.title)}</span>
                <button class="chat-delete" onclick="event.stopPropagation(); deleteChat('${c.id}')" title="Delete">
                    <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 00-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 00-7.5 0"/></svg>
                </button>
            </div>`;
            }).join("");
        }

        /* ‚ïê‚ïê Chat actions ‚ïê‚ïê */
        function newChat() {
            const id = 'chat_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8);
            const chat = { id, title: 'New Chat', model: modelSelect.value, messages: [], updatedAt: Date.now() };
            chats.push(chat);
            activeChatId = id;
            saveChats();
            renderChatArea();
            renderChatList();
            closeSidebar();
            pendingImages = [];
            renderPreviewStrip();
            userInput.focus();
        }

        function switchChat(id) {
            activeChatId = id;
            renderChatArea();
            renderChatList();
            closeSidebar();
        }

        function deleteChat(id) {
            chats = chats.filter(c => c.id !== id);
            saveChats();
            if (activeChatId === id) { activeChatId = null; renderChatArea(); }
            renderChatList();
        }

        function createChat(firstMessage) {
            const id = 'chat_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8);
            const title = firstMessage.length > 40 ? firstMessage.slice(0, 40) + '‚Ä¶' : firstMessage;
            const chat = { id, title, model: modelSelect.value, messages: [], updatedAt: Date.now() };
            chats.push(chat);
            activeChatId = id;
            saveChats();
            renderChatList();
            return chat;
        }

        /* ‚ïê‚ïê Render chat area ‚ïê‚ïê */
        function renderChatArea() {
            const chat = getActiveChat();
            if (!chat || chat.messages.length === 0) {
                chatArea.innerHTML = '';
                chatArea.appendChild(welcomeScreen);
                welcomeScreen.style.display = 'flex';
                return;
            }
            welcomeScreen.style.display = 'none';
            chatArea.innerHTML = '';
            chat.messages.forEach(m => appendMessageDOM(m.role === "user" ? "user" : "ai", m.content, m._imageData));
        }

        /* ‚ïê‚ïê Model loading ‚ïê‚ïê */
        async function loadModel(modelId) {
            if (isLoading) return;
            if (modelId === currentModelId && engine) return;

            isLoading = true;
            modelSelect.disabled = true;
            sendBtn.disabled = true;
            userInput.disabled = true;
            progressArea.classList.add("show");
            progressLabel.textContent = "Preparing‚Ä¶";
            progressPct.textContent = "0%";
            progressBar.style.width = "0%";

            if (engine) {
                try { await engine.unload(); } catch (_) { }
                engine = null;
                currentModelId = null;
            }

            const initProgressCallback = (report) => {
                progressLabel.textContent = report.text || "Downloading model‚Ä¶";
                const pct = Math.round((report.progress || 0) * 100);
                progressPct.textContent = pct + "%";
                progressBar.style.width = pct + "%";
            };

            try {
                // Compute limits are handled by the GPUAdapter monkey-patch above
                engine = await webllm.CreateMLCEngine(modelId, { initProgressCallback });
                currentModelId = modelId;
                progressArea.classList.remove("show");
                modelSelect.disabled = false;
                sendBtn.disabled = false;
                userInput.disabled = false;
                userInput.focus();
            } catch (err) {
                console.error("Model load error:", err);
                progressLabel.textContent = "‚ùå " + (err.message || "Failed to load model.");
                modelSelect.disabled = false;
            } finally {
                isLoading = false;
            }
        }

        /* ‚ïê‚ïê Build message content (text-only or multimodal) ‚ïê‚ïê */
        function buildUserContent(text, images) {
            if (!images || images.length === 0) return text;
            // Multimodal format (OpenAI-compatible)
            const content = [];
            images.forEach(url => {
                content.push({ type: "image_url", image_url: { url } });
            });
            content.push({ type: "text", text });
            return content;
        }

        /* ‚ïê‚ïê Extract display text from content ‚ïê‚ïê */
        function getDisplayText(content) {
            if (typeof content === "string") return content;
            if (Array.isArray(content)) {
                const textPart = content.find(p => p.type === "text");
                return textPart ? textPart.text : "";
            }
            return "";
        }

        /* ‚ïê‚ïê Extract images from content ‚ïê‚ïê */
        function getContentImages(content) {
            if (!Array.isArray(content)) return [];
            return content.filter(p => p.type === "image_url").map(p => p.image_url.url);
        }

        /* ‚ïê‚ïê Send message ‚ïê‚ïê */
        async function sendMessage(e) {
            e.preventDefault();
            if (isGenerating) return;

            const text = userInput.value.trim();
            if (!text && pendingImages.length === 0) return;

            // Check for /imagine command
            if (text.startsWith("/imagine ")) {
                userInput.value = "";
                const prompt = text.slice(9).trim();
                if (prompt) {
                    await generateImage(prompt);
                }
                return;
            }

            const images = [...pendingImages];
            pendingImages = [];
            renderPreviewStrip();

            // If images attached but no vision model, warn
            if (images.length > 0 && !isVisionModel(modelSelect.value)) {
                if (confirm("You attached images but the current model doesn't support vision. Switch to Phi-3.5 Vision?")) {
                    modelSelect.value = VISION_MODEL;
                    await loadModel(VISION_MODEL);
                    if (!engine) return;
                } else {
                    // Send without images as plain text
                    // Put images back? No, just proceed text-only
                }
            }

            // Auto-load model if none loaded yet
            if (!engine) {
                await loadModel(modelSelect.value);
                if (!engine) return;
            }

            userInput.value = "";

            const msgText = text || "What's in this image?";
            let chat = getActiveChat();
            if (!chat) {
                chat = createChat(msgText);
            } else if (chat.messages.length === 0) {
                chat.title = msgText.length > 40 ? msgText.slice(0, 40) + '‚Ä¶' : msgText;
                saveChats();
                renderChatList();
            }

            welcomeScreen.style.display = 'none';
            if (welcomeScreen.parentElement === chatArea) chatArea.removeChild(welcomeScreen);

            const userContent = buildUserContent(msgText, images);
            appendMessageDOM("user", userContent);
            chat.messages.push({ role: "user", content: userContent });
            chat.updatedAt = Date.now();
            saveChats();
            renderChatList();

            isGenerating = true;
            sendBtn.disabled = true;
            userInput.disabled = true;
            modelSelect.disabled = true;

            const typingEl = showTypingIndicator();

            try {
                const aiEl = appendMessageDOM("ai", "");
                typingEl.remove();

                const stream = await engine.chat.completions.create({
                    messages: chat.messages,
                    stream: true,
                    temperature: 0.7,
                    max_tokens: 1024,
                });

                let fullReply = "";
                for await (const chunk of stream) {
                    const delta = chunk.choices?.[0]?.delta?.content || "";
                    fullReply += delta;
                    aiEl.querySelector('.msg-bubble').innerHTML = renderMarkdown(fullReply);
                    chatArea.scrollTop = chatArea.scrollHeight;
                }

                chat.messages.push({ role: "assistant", content: fullReply });
                chat.updatedAt = Date.now();
                saveChats();
                renderChatList();
            } catch (err) {
                console.error(err);
                typingEl.remove();
                appendMessageDOM("ai", "‚ö†Ô∏è Error: " + (err.message || "Something went wrong."));
            } finally {
                isGenerating = false;
                sendBtn.disabled = false;
                userInput.disabled = false;
                modelSelect.disabled = false;
                userInput.focus();
            }
        }

        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Image Generation (SD Turbo) ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        let sdPipeline = null;
        let isSdLoading = false;

        async function triggerGenerate() {
            const text = userInput.value.trim();
            if (!text) {
                userInput.placeholder = "Type a prompt to generate an image‚Ä¶";
                userInput.focus();
                setTimeout(() => { userInput.placeholder = "Message WebAI‚Ä¶"; }, 2000);
                return;
            }
            userInput.value = "";
            await generateImage(text);
        }

        async function generateImage(prompt) {
            if (isSdLoading || isGenerating) return;

            // Ensure a chat exists
            let chat = getActiveChat();
            if (!chat) {
                chat = createChat("üé® " + prompt);
            } else if (chat.messages.length === 0) {
                chat.title = "üé® " + (prompt.length > 35 ? prompt.slice(0, 35) + '‚Ä¶' : prompt);
                saveChats();
                renderChatList();
            }

            welcomeScreen.style.display = 'none';
            if (welcomeScreen.parentElement === chatArea) chatArea.removeChild(welcomeScreen);

            // Show user prompt
            appendMessageDOM("user", "üé® " + prompt);
            chat.messages.push({ role: "user", content: "üé® " + prompt });
            chat.updatedAt = Date.now();
            saveChats();

            isGenerating = true;
            sendBtn.disabled = true;
            userInput.disabled = true;

            // Show progress
            const progressRow = document.createElement("div");
            progressRow.className = "msg-row ai";
            progressRow.innerHTML = `<div class="msg-avatar ai-av">AI</div><div class="msg-bubble ai-b sd-progress"><div class="sd-spinner"></div><span id="sdStatusText">Initializing image generation‚Ä¶</span></div>`;
            chatArea.appendChild(progressRow);
            chatArea.scrollTop = chatArea.scrollHeight;
            const statusText = progressRow.querySelector('#sdStatusText');

            try {
                // Use a canvas-based approach for a simple noise-to-image demo
                // In production, this would connect to ONNX Runtime Web SD Turbo
                statusText.textContent = "Generating image with WebGPU‚Ä¶";

                // Attempt to load and use SD Turbo via ONNX Runtime Web
                const imageDataUrl = await runSDTurboPipeline(prompt, (status) => {
                    statusText.textContent = status;
                });

                progressRow.remove();

                // Show result
                const aiEl = document.createElement("div");
                aiEl.className = "msg-row ai";
                aiEl.innerHTML = `<div class="msg-avatar ai-av">AI</div><div class="msg-bubble ai-b">
                    <p style="margin-bottom:8px;color:#a78bfa;">üé® Generated from: <em>${escapeHTML(prompt)}</em></p>
                    <div class="generated-image-wrap">
                        <img src="${imageDataUrl}" alt="Generated: ${escapeHTML(prompt)}" onclick="openLightbox('${imageDataUrl}')" style="cursor:zoom-in;" />
                        <button class="dl-btn" onclick="downloadGeneratedImage('${imageDataUrl}')">‚¨á Download</button>
                    </div>
                </div>`;
                chatArea.appendChild(aiEl);
                chatArea.scrollTop = chatArea.scrollHeight;

                // Store a compact reference in chat history
                chat.messages.push({ role: "assistant", content: `üé® Generated image from prompt: "${prompt}"\n[Image data stored locally]`, _imageData: imageDataUrl });
                chat.updatedAt = Date.now();
                saveChats();
                renderChatList();

            } catch (err) {
                console.error("SD Turbo error:", err);
                progressRow.remove();
                appendMessageDOM("ai", "‚ö†Ô∏è Image generation failed: " + (err.message || "Unknown error") + "\n\nNote: Local image generation requires WebGPU support and may not work in all browsers. The SD Turbo ONNX model needs to be hosted and accessible.");
            } finally {
                isGenerating = false;
                sendBtn.disabled = false;
                userInput.disabled = false;
                userInput.focus();
            }
        }

        /* ‚îÄ‚îÄ SD Turbo pipeline ‚îÄ‚îÄ */
        async function runSDTurboPipeline(prompt, onStatus) {
            // Check for ONNX Runtime Web availability
            if (typeof ort === 'undefined') {
                onStatus("Loading ONNX Runtime Web‚Ä¶");
                await loadScript("https://cdn.jsdelivr.net/npm/onnxruntime-web@1.21.0/dist/ort.all.min.js");
            }

            if (!navigator.gpu) {
                throw new Error("WebGPU is not available. Image generation requires WebGPU support.");
            }

            onStatus("Preparing image generation pipeline‚Ä¶");

            // For SD Turbo, we need: text_encoder, unet, vae_decoder ONNX models
            // These are large models (~1-2GB total) that need to be hosted somewhere
            // We'll use a fallback approach: try to load from HuggingFace, fall back to a procedural generation

            try {
                // Try loading the actual SD Turbo pipeline
                onStatus("Loading Stable Diffusion Turbo model‚Ä¶ (first time may take a few minutes)");

                // Use the Hugging Face hosted ONNX SD Turbo models
                const baseUrl = "https://huggingface.co/schmuell/sd-turbo-ort-web/resolve/main";

                ort.env.wasm.wasmPaths = "https://cdn.jsdelivr.net/npm/onnxruntime-web@1.21.0/dist/";

                // Load text tokenizer data
                onStatus("Loading text encoder‚Ä¶");
                const tokenizerResp = await fetch(`${baseUrl}/tokenizer/merges.txt`);
                if (!tokenizerResp.ok) throw new Error("Could not load tokenizer");

                // Create inference sessions
                onStatus("Loading UNet model‚Ä¶ (this is the largest component)");

                const sessionOptions = {
                    executionProviders: ['webgpu', 'wasm'],
                    graphOptimizationLevel: 'all',
                };

                // Load the models
                const [textEncoderSession, unetSession, vaeSession] = await Promise.all([
                    ort.InferenceSession.create(`${baseUrl}/text_encoder/model.onnx`, sessionOptions).catch(() => null),
                    ort.InferenceSession.create(`${baseUrl}/unet/model.onnx`, sessionOptions).catch(() => null),
                    ort.InferenceSession.create(`${baseUrl}/vae_decoder/model.onnx`, sessionOptions).catch(() => null),
                ]);

                if (!textEncoderSession || !unetSession || !vaeSession) {
                    throw new Error("ONNX_LOAD_FAILED");
                }

                onStatus("Running inference‚Ä¶");

                // Simple text encoding (placeholder tokenization)
                const tokenIds = simpleTokenize(prompt, 77);
                const inputIds = new ort.Tensor('int32', new Int32Array(tokenIds), [1, 77]);

                // Run text encoder
                const textEncResult = await textEncoderSession.run({ input_ids: inputIds });
                const textEmbeddings = textEncResult.last_hidden_state;

                // Generate random latent
                const latentSize = 64 * 64;
                const latentData = new Float32Array(4 * latentSize);
                for (let i = 0; i < latentData.length; i++) {
                    latentData[i] = gaussianRandom();
                }
                const latent = new ort.Tensor('float32', latentData, [1, 4, 64, 64]);
                const timestep = new ort.Tensor('int64', BigInt64Array.from([BigInt(1)]), [1]);

                // Run UNet (single step for Turbo)
                onStatus("Denoising‚Ä¶");
                const unetResult = await unetSession.run({
                    sample: latent,
                    timestep: timestep,
                    encoder_hidden_states: textEmbeddings
                });
                const denoisedLatent = unetResult.out_sample;

                // Run VAE decoder
                onStatus("Decoding image‚Ä¶");
                const scaledLatent = new ort.Tensor('float32',
                    denoisedLatent.cpuData.map(v => v / 0.18215),
                    denoisedLatent.dims
                );
                const vaeResult = await vaeSession.run({ latent_sample: scaledLatent });
                const imageData = vaeResult.sample;

                // Convert to canvas
                return tensorToDataUrl(imageData);

            } catch (err) {
                if (err.message !== "ONNX_LOAD_FAILED") console.warn("SD Turbo ONNX pipeline error:", err);

                // Fallback: generate a stylized procedural image using Canvas + WebGPU
                onStatus("Using local procedural generation‚Ä¶");
                return generateProceduralImage(prompt);
            }
        }

        /* ‚îÄ‚îÄ Helper: load external script ‚îÄ‚îÄ */
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                if (document.querySelector(`script[src="${src}"]`)) { resolve(); return; }
                const s = document.createElement("script");
                s.src = src;
                s.onload = resolve;
                s.onerror = reject;
                document.head.appendChild(s);
            });
        }

        /* ‚îÄ‚îÄ Simple CLIP-like tokenizer (very simplified) ‚îÄ‚îÄ */
        function simpleTokenize(text, maxLen) {
            const tokens = [49406]; // BOS
            const words = text.toLowerCase().split(/\s+/);
            for (const word of words) {
                // Simple char-level hash to generate token IDs
                let hash = 0;
                for (let i = 0; i < word.length; i++) {
                    hash = ((hash << 5) - hash + word.charCodeAt(i)) & 0x7fff;
                }
                tokens.push(hash + 1000);
                if (tokens.length >= maxLen - 1) break;
            }
            tokens.push(49407); // EOS
            while (tokens.length < maxLen) tokens.push(0); // pad
            return tokens;
        }

        /* ‚îÄ‚îÄ Gaussian random number ‚îÄ‚îÄ */
        function gaussianRandom() {
            let u = 0, v = 0;
            while (u === 0) u = Math.random();
            while (v === 0) v = Math.random();
            return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        }

        /* ‚îÄ‚îÄ Convert ONNX tensor to data URL ‚îÄ‚îÄ */
        function tensorToDataUrl(tensor) {
            const [_, channels, height, width] = tensor.dims;
            const data = tensor.cpuData || tensor.data;
            const canvas = document.createElement("canvas");
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext("2d");
            const imgData = ctx.createImageData(width, height);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    for (let c = 0; c < 3; c++) {
                        const val = data[c * height * width + y * width + x];
                        imgData.data[idx + c] = Math.min(255, Math.max(0, Math.round((val + 1) * 127.5)));
                    }
                    imgData.data[idx + 3] = 255;
                }
            }
            ctx.putImageData(imgData, 0, 0);
            return canvas.toDataURL("image/png");
        }

        /* ‚îÄ‚îÄ Procedural image fallback (stylized gradient art) ‚îÄ‚îÄ */
        function generateProceduralImage(prompt) {
            const canvas = document.createElement("canvas");
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext("2d");

            // Seed from prompt
            let seed = 0;
            for (let i = 0; i < prompt.length; i++) {
                seed = ((seed << 5) - seed + prompt.charCodeAt(i)) | 0;
            }
            const rng = () => { seed = (seed * 1103515245 + 12345) & 0x7fffffff; return seed / 0x7fffffff; };

            // Generate colors from prompt
            const hue1 = rng() * 360;
            const hue2 = (hue1 + 60 + rng() * 120) % 360;
            const hue3 = (hue2 + 60 + rng() * 120) % 360;

            // Background gradient
            const grad = ctx.createLinearGradient(0, 0, 512, 512);
            grad.addColorStop(0, `hsl(${hue1}, 70%, 20%)`);
            grad.addColorStop(0.5, `hsl(${hue2}, 60%, 15%)`);
            grad.addColorStop(1, `hsl(${hue3}, 70%, 10%)`);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 512, 512);

            // Abstract shapes
            for (let i = 0; i < 12 + Math.floor(rng() * 8); i++) {
                const x = rng() * 512;
                const y = rng() * 512;
                const r = 30 + rng() * 120;
                const h = (hue1 + rng() * 180) % 360;
                ctx.beginPath();

                if (rng() > 0.5) {
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                } else {
                    ctx.ellipse(x, y, r, r * (0.5 + rng()), rng() * Math.PI, 0, Math.PI * 2);
                }

                const grd = ctx.createRadialGradient(x, y, 0, x, y, r);
                grd.addColorStop(0, `hsla(${h}, 80%, 60%, ${0.15 + rng() * 0.25})`);
                grd.addColorStop(1, `hsla(${h}, 80%, 40%, 0)`);
                ctx.fillStyle = grd;
                ctx.fill();
            }

            // Flowing lines
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                let x = rng() * 512, y = rng() * 512;
                ctx.moveTo(x, y);
                for (let j = 0; j < 6; j++) {
                    const cp1x = rng() * 512, cp1y = rng() * 512;
                    const cp2x = rng() * 512, cp2y = rng() * 512;
                    x = rng() * 512; y = rng() * 512;
                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
                }
                ctx.strokeStyle = `hsla(${hue2 + rng() * 60}, 70%, 70%, ${0.1 + rng() * 0.2})`;
                ctx.lineWidth = 1 + rng() * 3;
                ctx.stroke();
            }

            // Light particles
            for (let i = 0; i < 40; i++) {
                const x = rng() * 512, y = rng() * 512, r = 1 + rng() * 3;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fillStyle = `hsla(${rng() * 360}, 100%, 90%, ${0.3 + rng() * 0.5})`;
                ctx.fill();
            }

            // Prompt text as watermark
            ctx.fillStyle = "rgba(255,255,255,0.07)";
            ctx.font = "14px Inter, sans-serif";
            ctx.textAlign = "center";
            ctx.fillText(prompt.slice(0, 60), 256, 490);

            // Note overlay
            ctx.fillStyle = "rgba(167,139,250,0.8)";
            ctx.font = "bold 11px Inter, sans-serif";
            ctx.textAlign = "left";
            ctx.fillText("‚ö° Procedural ‚Ä¢ Full SD Turbo requires ONNX model hosting", 12, 20);

            return canvas.toDataURL("image/png");
        }

        /* ‚ïê‚ïê DOM helpers ‚ïê‚ïê */
        function appendMessageDOM(role, content, imageData) {
            const isUser = role === "user";
            const row = document.createElement("div");
            row.className = `msg-row ${isUser ? 'user' : 'ai'}`;

            if (isUser) {
                const images = getContentImages(content);
                const text = getDisplayText(content);
                let imgHtml = images.map(src =>
                    `<img class="image-in-bubble" src="${src}" alt="Attached image" onclick="openLightbox('${src}')" />`
                ).join("");
                row.innerHTML = `<div class="msg-bubble user-b">${imgHtml}${escapeHTML(text)}</div><div class="msg-avatar user-av">You</div>`;
            } else if (imageData) {
                // Re-render a generated image from stored data
                const promptMatch = typeof content === "string" && content.match(/Generated image from prompt: "(.+?)"/);
                const prompt = promptMatch ? promptMatch[1] : "image";
                row.innerHTML = `<div class="msg-avatar ai-av">AI</div><div class="msg-bubble ai-b">
                    <p style="margin-bottom:8px;color:#a78bfa;">üé® Generated from: <em>${escapeHTML(prompt)}</em></p>
                    <div class="generated-image-wrap">
                        <img src="${imageData}" alt="Generated: ${escapeHTML(prompt)}" onclick="openLightbox('${imageData}')" style="cursor:zoom-in;" />
                        <button class="dl-btn" onclick="downloadGeneratedImage('${imageData}')">‚¨á Download</button>
                    </div>
                </div>`;
            } else {
                const text = typeof content === "string" ? content : getDisplayText(content);
                const rendered = text ? renderMarkdown(text) : '';
                row.innerHTML = `<div class="msg-avatar ai-av">AI</div><div class="msg-bubble ai-b">${rendered}</div>`;
            }
            chatArea.appendChild(row);
            chatArea.scrollTop = chatArea.scrollHeight;
            return row;
        }

        function showTypingIndicator() {
            const row = document.createElement("div");
            row.className = "msg-row ai";
            row.innerHTML = `<div class="msg-avatar ai-av">AI</div><div class="msg-bubble ai-b typing"><span></span><span></span><span></span></div>`;
            chatArea.appendChild(row);
            chatArea.scrollTop = chatArea.scrollHeight;
            return row;
        }

        function escapeHTML(str) {
            if (typeof str !== "string") return "";
            const d = document.createElement("div");
            d.textContent = str;
            return d.innerHTML;
        }

        function renderMarkdown(text) {
            try {
                const renderer = new marked.Renderer();
                renderer.code = function ({ text: code, lang }) {
                    let highlighted;
                    if (lang && hljs.getLanguage(lang)) {
                        highlighted = hljs.highlight(code, { language: lang }).value;
                    } else {
                        highlighted = hljs.highlightAuto(code).value;
                    }
                    const langLabel = lang ? `<span style="position:absolute;top:7px;left:12px;font-size:0.65rem;color:#525252;">${escapeHTML(lang)}</span>` : '';
                    return `<pre>${langLabel}<button class="copy-btn" onclick="copyCode(this)">Copy</button><code>${highlighted}</code></pre>`;
                };
                return marked.parse(text, { breaks: true, renderer });
            } catch {
                return escapeHTML(text);
            }
        }

        function copyCode(btn) {
            const pre = btn.closest('pre');
            const code = pre.querySelector('code').textContent;
            navigator.clipboard.writeText(code).then(() => {
                btn.textContent = 'Copied!';
                btn.classList.add('copied');
                setTimeout(() => {
                    btn.textContent = 'Copy';
                    btn.classList.remove('copied');
                }, 1500);
            });
        }
        window.copyCode = copyCode;

        /* ‚ïê‚ïê Mobile sidebar ‚ïê‚ïê */
        function toggleSidebar() {
            sidebar.classList.toggle("open");
            sidebarOverlay.classList.toggle("show");
        }
        function closeSidebar() {
            sidebar.classList.remove("open");
            sidebarOverlay.classList.remove("show");
        }

        /* ‚ïê‚ïê Init ‚ïê‚ïê */
        renderChatList();
        renderChatArea();

        // WebGPU check
        if (!navigator.gpu) {
            modelSelect.disabled = true;
            welcomeScreen.innerHTML = `
            <p style="color:#ef4444; font-weight:500; margin-bottom:8px;">‚ö†Ô∏è WebGPU is not supported in this browser.</p>
            <p style="color:#737373; font-size:0.82rem;">Please use Chrome 113+, Edge 113+, or another WebGPU-enabled browser.</p>`;
        } else {
            // Auto-load the default model on page open
            loadModel(modelSelect.value);
        }
    </script>
</body>

</html>